const HomePage: Devvit.BlockComponent<{ navigate: (page: PageType) => void }> = ({ navigate }, context)  => {
  const { postId } = context;
  const mySession = sessionId();
  const myPostId = postId ?? 'defaultPostId'; 
  const [currCard, setCard] = useState(async () => {
    const cardData = await context.redis.get(myPostId);
    if (cardData) {
      return cardData;
    }
    return 'back.png';
  });


  const [currCard, setCard] = useState('back.png');
  const [drawnCards, setCards] = useState<string[]>([]);;
  const [totalCurrCards, setTotal] = useState(0);
  const [currDeck, setDeck] = useState(shuffle([...DECK]));
  const [plus, setPlus] = useState(1);
  const [score, setScore] = useState(0);
  const [reset, setReset] = useState(false);
  const [maxTotal, setMaxTotal] = useState(0);

  // Variables for delaying the button
  const [lastClickTime, setLastClickTime] = useState(0);
  const [isDebouncing, setIsDebouncing] = useState(false);
  const DEBOUNCE_DELAY = 1000; 


  const countPage: Devvit.Blocks.OnPressEventHandler = () => {
    navigate(PageType.COUNTPAGE);
  };

  const channel = useChannel<RealtimeMessage>({
    name: 'events',
    onMessage: (msg) => {
      if (msg.session === mySession || msg.postId !== myPostId) {
        //Ignore my updates b/c they have already been rendered
        return;
      }
      const payload = msg.payload;
      setCard(payload.card);
      setCards(payload.drawnCards);
      setTotal(payload.totalCurrCards);
      setDeck([...payload.currDeck]);
      setPlus(payload.plus);
      setReset(payload.reset);
      setMaxTotal(payload.maxTotal);
    },
  });

  channel.subscribe();


  // Add delay to the button to avoid spamming
  const updateInterval = useInterval(() => {
    const now = Date.now();
    setIsDebouncing(now - lastClickTime <= DEBOUNCE_DELAY);
  }, 100).start();

  const handleClick = async () => {
    const now = Date.now();
    setLastClickTime(now);
    setIsDebouncing(true);
    
    // Logic for drawing a card
    const { updatedCard, updatedDeck, updatedDrawnCards, updatedTotal, updatedScore, updatedReset, updatedMax } = getCard(currDeck, drawnCards, totalCurrCards, score, reset, maxTotal);
    setScore(updatedScore);
    const payload: Payload = { card: updatedCard, drawnCards: updatedDrawnCards, totalCurrCards: updatedTotal, currDeck: updatedDeck, plus: calcPlus(updatedTotal), reset: updatedReset, maxTotal: updatedMax};
    const message: RealtimeMessage = { payload, session: mySession, postId: myPostId };

    // Send the message with the payload
    await channel.send(message);
  };
  return (
    <zstack width='100%' height='100%'>
      <image 
      url='background.png'
      imageHeight={512}
      imageWidth={720}
      resizeMode='cover'
      />
      
      <vstack height="100%" width="100%" gap="medium" alignment="center middle">
        <image
          url={currCard?.toString() || 'back.png'}
          description="card"
          imageHeight={384}
          imageWidth={384}
          height="300px"
          width="300px"
        />

        <text size="large" color='black'>Remaining cards: {currDeck.length}</text>
        <text size="large" color='black'>Total current cards: {totalCurrCards} - Plus: {calcPlus(totalCurrCards)}</text>
        <text color='black' size="large">{`Last 5 cards: ${getLastFiveCards(drawnCards)}`}</text>
        <text color='black' size="xxlarge">{`Score: ${score}`}</text>
        <hstack gap='medium'>
          <button appearance='primary'>Rules</button>
          <button onPress={handleClick} disabled={isDebouncing} appearance='primary'>
            Draw!
          </button>
          <button appearance='primary' onPress={countPage}>Leaderboard</button>
        </hstack>
      </vstack>
    </zstack>
  )
};